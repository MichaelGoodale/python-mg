from __future__ import annotations
from dataclasses import dataclass
from python_mg._lib_name import SyntacticStructure, MGNode, MGEdge
from PIL import Image
import rustworkx as rx
from rustworkx.visualization import graphviz_draw


def sort_key(G: rx.PyDiGraph[MGNode, MGEdge], e: int) -> int:
    (n, _) = G.get_edge_endpoints_by_index(e)
    return G.get_node_data(n).trace_id()


@dataclass
class StolenHead:
    """A head that has been stolen"""

    s: str
    """ the stolen head """


@dataclass
class Mover:
    """A list of words used to indicate where movement has occurred. See :meth:`python_mg.ParseTree.base_string`"""

    s: list[str | Mover]
    """ The moved words """

    trace: int
    """ the trace ID"""


@dataclass
class Trace:
    """A representation of a trace index left by movement"""

    trace: int
    """ the trace ID """


def node_attrs(node: MGNode):
    attrs = {"label": str(node), "ordering": "out"}
    if node.is_stolen():
        attrs["style"] = "dashed"
        attrs["color"] = "gray"
        attrs["fontcolor"] = "gray"

    return attrs


def edge_attrs(edge: MGEdge) -> dict[str, str]:
    if edge.is_move() or edge.is_head_move():
        return {"style": "dashed", "constraint": "false"}
    return {}


class ParseTree:
    """A class used for ParseTree that is generated by :meth:`python_mg.SyntacticStructure.to_tree`.
    It can be used to get a GraphViz representation of the tree or to investigate the ParseTree as a graph.
    """

    def __init__(
        self, G: rx.PyDiGraph[MGNode, MGEdge], root: int, structure: SyntacticStructure
    ):
        self.root: int = root
        self.structure: SyntacticStructure = structure
        self.G: rx.PyDiGraph[MGNode, MGEdge] = G
        """PyDiGraph[MGNode, MGEdge]: A rustworkx PyDiGraph which contains the syntactice structure of a sentence"""

    def normal_string(self) -> str:
        """The string used by a ParseTree

        Returns
        -------
        str
            the parsed sentence
        """
        return str(self.structure)

    def base_string(self) -> list[str | Mover | Trace | StolenHead]:
        """A richer representation of the parsed string, with traces where movement had occurred, and :meth:`python_mg.Mover` objects to indicated moved phrases.

        Returns
        -------
        str
            the parsed sentence
        """
        linear_order = self.__explore(self.root)
        return linear_order

    def to_dot(self) -> str | None:
        """Converts a tree to GraphViz DOT format

        Returns
        -------
        str
            The dot file for this tree
        """
        return self.G.to_dot(node_attr=node_attrs, edge_attr=edge_attrs)

    def to_image(self) -> Image.Image:
        """Converts a tree to a PIL Image

        Returns
        -------
        Image
            An image representation of the tree
        """
        return graphviz_draw(
            self.G,
            node_attr_fn=node_attrs,
            edge_attr_fn=edge_attrs,
        )

    def __explore(self, n_i: int) -> list[str | Mover | Trace | StolenHead]:
        out: list[str | Mover | Trace | StolenHead] = []
        children = [(str(e), n) for (_, n, e) in self.G.out_edges(n_i)]
        left_children = [n for (e, n) in children if e == "MergeLeft"]
        right_children = [n for (e, n) in children if e == "MergeRight"]
        for child in left_children:
            out += self.__explore(child)

        node = self.G.get_node_data(n_i)
        s = self.G.get_node_data(n_i).lemma_string()
        if node.is_trace():
            out.append(Trace(node.trace_id()))
        elif s != "":
            out.append(s)

        for child in right_children:
            out += self.__explore(child)

        return out


def to_tree(self: SyntacticStructure) -> ParseTree:
    """Converts a SyntacticStructure to a ParseTree

    Returns
    -------
    The SyntacticStructure as a :meth:`python_mg.ParseTree`
    """
    (nodes, edges, root) = self.__to_tree_inner()  # pyright: ignore[reportPrivateUsage]

    # This will usually be the identity function, but on the off chance its not, we do this.
    # Waste computation in exchange for not having a horrible headache
    old2new: dict[int, int] = {}

    G = rx.PyDiGraph()
    for old_node_i, node in nodes:
        new_node = G.add_node(node)
        old2new[old_node_i] = new_node

    for old_src, old_tgt, edge in edges:
        _ = G.add_edge(old2new[old_src], old2new[old_tgt], edge)

    return ParseTree(G, old2new[root], self)


SyntacticStructure.to_tree = to_tree
